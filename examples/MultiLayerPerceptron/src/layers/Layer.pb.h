// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Layer.proto

#ifndef PROTOBUF_Layer_2eproto__INCLUDED
#define PROTOBUF_Layer_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace Layer {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_Layer_2eproto();
void protobuf_AssignDesc_Layer_2eproto();
void protobuf_ShutdownFile_Layer_2eproto();

class layer;
class layer_Tensor;
class layer_Kernel;

// ===================================================================

class layer_Tensor : public ::google::protobuf::Message {
 public:
  layer_Tensor();
  virtual ~layer_Tensor();

  layer_Tensor(const layer_Tensor& from);

  inline layer_Tensor& operator=(const layer_Tensor& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const layer_Tensor& default_instance();

  void Swap(layer_Tensor* other);

  // implements Message ----------------------------------------------

  layer_Tensor* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const layer_Tensor& from);
  void MergeFrom(const layer_Tensor& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // repeated int32 shape = 2;
  inline int shape_size() const;
  inline void clear_shape();
  static const int kShapeFieldNumber = 2;
  inline ::google::protobuf::int32 shape(int index) const;
  inline void set_shape(int index, ::google::protobuf::int32 value);
  inline void add_shape(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      shape() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_shape();

  // repeated float data = 3 [packed = true];
  inline int data_size() const;
  inline void clear_data();
  static const int kDataFieldNumber = 3;
  inline float data(int index) const;
  inline void set_data(int index, float value);
  inline void add_data(float value);
  inline const ::google::protobuf::RepeatedField< float >&
      data() const;
  inline ::google::protobuf::RepeatedField< float >*
      mutable_data();

  // @@protoc_insertion_point(class_scope:Layer.layer.Tensor)
 private:
  inline void set_has_name();
  inline void clear_has_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > shape_;
  ::google::protobuf::RepeatedField< float > data_;
  mutable int _data_cached_byte_size_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_Layer_2eproto();
  friend void protobuf_AssignDesc_Layer_2eproto();
  friend void protobuf_ShutdownFile_Layer_2eproto();

  void InitAsDefaultInstance();
  static layer_Tensor* default_instance_;
};
// -------------------------------------------------------------------

class layer_Kernel : public ::google::protobuf::Message {
 public:
  layer_Kernel();
  virtual ~layer_Kernel();

  layer_Kernel(const layer_Kernel& from);

  inline layer_Kernel& operator=(const layer_Kernel& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const layer_Kernel& default_instance();

  void Swap(layer_Kernel* other);

  // implements Message ----------------------------------------------

  layer_Kernel* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const layer_Kernel& from);
  void MergeFrom(const layer_Kernel& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // repeated int32 shape = 2;
  inline int shape_size() const;
  inline void clear_shape();
  static const int kShapeFieldNumber = 2;
  inline ::google::protobuf::int32 shape(int index) const;
  inline void set_shape(int index, ::google::protobuf::int32 value);
  inline void add_shape(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      shape() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_shape();

  // repeated float data = 3 [packed = true];
  inline int data_size() const;
  inline void clear_data();
  static const int kDataFieldNumber = 3;
  inline float data(int index) const;
  inline void set_data(int index, float value);
  inline void add_data(float value);
  inline const ::google::protobuf::RepeatedField< float >&
      data() const;
  inline ::google::protobuf::RepeatedField< float >*
      mutable_data();

  // repeated int32 strides = 4;
  inline int strides_size() const;
  inline void clear_strides();
  static const int kStridesFieldNumber = 4;
  inline ::google::protobuf::int32 strides(int index) const;
  inline void set_strides(int index, ::google::protobuf::int32 value);
  inline void add_strides(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      strides() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_strides();

  // optional string padding = 5;
  inline bool has_padding() const;
  inline void clear_padding();
  static const int kPaddingFieldNumber = 5;
  inline const ::std::string& padding() const;
  inline void set_padding(const ::std::string& value);
  inline void set_padding(const char* value);
  inline void set_padding(const char* value, size_t size);
  inline ::std::string* mutable_padding();
  inline ::std::string* release_padding();
  inline void set_allocated_padding(::std::string* padding);

  // @@protoc_insertion_point(class_scope:Layer.layer.Kernel)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_padding();
  inline void clear_has_padding();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > shape_;
  ::google::protobuf::RepeatedField< float > data_;
  mutable int _data_cached_byte_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > strides_;
  ::std::string* padding_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_Layer_2eproto();
  friend void protobuf_AssignDesc_Layer_2eproto();
  friend void protobuf_ShutdownFile_Layer_2eproto();

  void InitAsDefaultInstance();
  static layer_Kernel* default_instance_;
};
// -------------------------------------------------------------------

class layer : public ::google::protobuf::Message {
 public:
  layer();
  virtual ~layer();

  layer(const layer& from);

  inline layer& operator=(const layer& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const layer& default_instance();

  void Swap(layer* other);

  // implements Message ----------------------------------------------

  layer* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const layer& from);
  void MergeFrom(const layer& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef layer_Tensor Tensor;
  typedef layer_Kernel Kernel;

  // accessors -------------------------------------------------------

  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required .Layer.layer.Tensor input = 2;
  inline bool has_input() const;
  inline void clear_input();
  static const int kInputFieldNumber = 2;
  inline const ::Layer::layer_Tensor& input() const;
  inline ::Layer::layer_Tensor* mutable_input();
  inline ::Layer::layer_Tensor* release_input();
  inline void set_allocated_input(::Layer::layer_Tensor* input);

  // required .Layer.layer.Tensor output = 3;
  inline bool has_output() const;
  inline void clear_output();
  static const int kOutputFieldNumber = 3;
  inline const ::Layer::layer_Tensor& output() const;
  inline ::Layer::layer_Tensor* mutable_output();
  inline ::Layer::layer_Tensor* release_output();
  inline void set_allocated_output(::Layer::layer_Tensor* output);

  // optional .Layer.layer.Tensor grad_backprop = 4;
  inline bool has_grad_backprop() const;
  inline void clear_grad_backprop();
  static const int kGradBackpropFieldNumber = 4;
  inline const ::Layer::layer_Tensor& grad_backprop() const;
  inline ::Layer::layer_Tensor* mutable_grad_backprop();
  inline ::Layer::layer_Tensor* release_grad_backprop();
  inline void set_allocated_grad_backprop(::Layer::layer_Tensor* grad_backprop);

  // optional .Layer.layer.Kernel kernel = 5;
  inline bool has_kernel() const;
  inline void clear_kernel();
  static const int kKernelFieldNumber = 5;
  inline const ::Layer::layer_Kernel& kernel() const;
  inline ::Layer::layer_Kernel* mutable_kernel();
  inline ::Layer::layer_Kernel* release_kernel();
  inline void set_allocated_kernel(::Layer::layer_Kernel* kernel);

  // optional .Layer.layer.Tensor grad_filter = 6;
  inline bool has_grad_filter() const;
  inline void clear_grad_filter();
  static const int kGradFilterFieldNumber = 6;
  inline const ::Layer::layer_Tensor& grad_filter() const;
  inline ::Layer::layer_Tensor* mutable_grad_filter();
  inline ::Layer::layer_Tensor* release_grad_filter();
  inline void set_allocated_grad_filter(::Layer::layer_Tensor* grad_filter);

  // @@protoc_insertion_point(class_scope:Layer.layer)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_input();
  inline void clear_has_input();
  inline void set_has_output();
  inline void clear_has_output();
  inline void set_has_grad_backprop();
  inline void clear_has_grad_backprop();
  inline void set_has_kernel();
  inline void clear_has_kernel();
  inline void set_has_grad_filter();
  inline void clear_has_grad_filter();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::Layer::layer_Tensor* input_;
  ::Layer::layer_Tensor* output_;
  ::Layer::layer_Tensor* grad_backprop_;
  ::Layer::layer_Kernel* kernel_;
  ::Layer::layer_Tensor* grad_filter_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_Layer_2eproto();
  friend void protobuf_AssignDesc_Layer_2eproto();
  friend void protobuf_ShutdownFile_Layer_2eproto();

  void InitAsDefaultInstance();
  static layer* default_instance_;
};
// ===================================================================


// ===================================================================

// layer_Tensor

// optional string name = 1;
inline bool layer_Tensor::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void layer_Tensor::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void layer_Tensor::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void layer_Tensor::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& layer_Tensor::name() const {
  return *name_;
}
inline void layer_Tensor::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void layer_Tensor::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void layer_Tensor::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* layer_Tensor::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* layer_Tensor::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void layer_Tensor::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated int32 shape = 2;
inline int layer_Tensor::shape_size() const {
  return shape_.size();
}
inline void layer_Tensor::clear_shape() {
  shape_.Clear();
}
inline ::google::protobuf::int32 layer_Tensor::shape(int index) const {
  return shape_.Get(index);
}
inline void layer_Tensor::set_shape(int index, ::google::protobuf::int32 value) {
  shape_.Set(index, value);
}
inline void layer_Tensor::add_shape(::google::protobuf::int32 value) {
  shape_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
layer_Tensor::shape() const {
  return shape_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
layer_Tensor::mutable_shape() {
  return &shape_;
}

// repeated float data = 3 [packed = true];
inline int layer_Tensor::data_size() const {
  return data_.size();
}
inline void layer_Tensor::clear_data() {
  data_.Clear();
}
inline float layer_Tensor::data(int index) const {
  return data_.Get(index);
}
inline void layer_Tensor::set_data(int index, float value) {
  data_.Set(index, value);
}
inline void layer_Tensor::add_data(float value) {
  data_.Add(value);
}
inline const ::google::protobuf::RepeatedField< float >&
layer_Tensor::data() const {
  return data_;
}
inline ::google::protobuf::RepeatedField< float >*
layer_Tensor::mutable_data() {
  return &data_;
}

// -------------------------------------------------------------------

// layer_Kernel

// optional string name = 1;
inline bool layer_Kernel::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void layer_Kernel::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void layer_Kernel::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void layer_Kernel::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& layer_Kernel::name() const {
  return *name_;
}
inline void layer_Kernel::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void layer_Kernel::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void layer_Kernel::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* layer_Kernel::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* layer_Kernel::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void layer_Kernel::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated int32 shape = 2;
inline int layer_Kernel::shape_size() const {
  return shape_.size();
}
inline void layer_Kernel::clear_shape() {
  shape_.Clear();
}
inline ::google::protobuf::int32 layer_Kernel::shape(int index) const {
  return shape_.Get(index);
}
inline void layer_Kernel::set_shape(int index, ::google::protobuf::int32 value) {
  shape_.Set(index, value);
}
inline void layer_Kernel::add_shape(::google::protobuf::int32 value) {
  shape_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
layer_Kernel::shape() const {
  return shape_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
layer_Kernel::mutable_shape() {
  return &shape_;
}

// repeated float data = 3 [packed = true];
inline int layer_Kernel::data_size() const {
  return data_.size();
}
inline void layer_Kernel::clear_data() {
  data_.Clear();
}
inline float layer_Kernel::data(int index) const {
  return data_.Get(index);
}
inline void layer_Kernel::set_data(int index, float value) {
  data_.Set(index, value);
}
inline void layer_Kernel::add_data(float value) {
  data_.Add(value);
}
inline const ::google::protobuf::RepeatedField< float >&
layer_Kernel::data() const {
  return data_;
}
inline ::google::protobuf::RepeatedField< float >*
layer_Kernel::mutable_data() {
  return &data_;
}

// repeated int32 strides = 4;
inline int layer_Kernel::strides_size() const {
  return strides_.size();
}
inline void layer_Kernel::clear_strides() {
  strides_.Clear();
}
inline ::google::protobuf::int32 layer_Kernel::strides(int index) const {
  return strides_.Get(index);
}
inline void layer_Kernel::set_strides(int index, ::google::protobuf::int32 value) {
  strides_.Set(index, value);
}
inline void layer_Kernel::add_strides(::google::protobuf::int32 value) {
  strides_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
layer_Kernel::strides() const {
  return strides_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
layer_Kernel::mutable_strides() {
  return &strides_;
}

// optional string padding = 5;
inline bool layer_Kernel::has_padding() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void layer_Kernel::set_has_padding() {
  _has_bits_[0] |= 0x00000010u;
}
inline void layer_Kernel::clear_has_padding() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void layer_Kernel::clear_padding() {
  if (padding_ != &::google::protobuf::internal::kEmptyString) {
    padding_->clear();
  }
  clear_has_padding();
}
inline const ::std::string& layer_Kernel::padding() const {
  return *padding_;
}
inline void layer_Kernel::set_padding(const ::std::string& value) {
  set_has_padding();
  if (padding_ == &::google::protobuf::internal::kEmptyString) {
    padding_ = new ::std::string;
  }
  padding_->assign(value);
}
inline void layer_Kernel::set_padding(const char* value) {
  set_has_padding();
  if (padding_ == &::google::protobuf::internal::kEmptyString) {
    padding_ = new ::std::string;
  }
  padding_->assign(value);
}
inline void layer_Kernel::set_padding(const char* value, size_t size) {
  set_has_padding();
  if (padding_ == &::google::protobuf::internal::kEmptyString) {
    padding_ = new ::std::string;
  }
  padding_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* layer_Kernel::mutable_padding() {
  set_has_padding();
  if (padding_ == &::google::protobuf::internal::kEmptyString) {
    padding_ = new ::std::string;
  }
  return padding_;
}
inline ::std::string* layer_Kernel::release_padding() {
  clear_has_padding();
  if (padding_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = padding_;
    padding_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void layer_Kernel::set_allocated_padding(::std::string* padding) {
  if (padding_ != &::google::protobuf::internal::kEmptyString) {
    delete padding_;
  }
  if (padding) {
    set_has_padding();
    padding_ = padding;
  } else {
    clear_has_padding();
    padding_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// layer

// optional string name = 1;
inline bool layer::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void layer::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void layer::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void layer::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& layer::name() const {
  return *name_;
}
inline void layer::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void layer::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void layer::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* layer::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* layer::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void layer::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required .Layer.layer.Tensor input = 2;
inline bool layer::has_input() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void layer::set_has_input() {
  _has_bits_[0] |= 0x00000002u;
}
inline void layer::clear_has_input() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void layer::clear_input() {
  if (input_ != NULL) input_->::Layer::layer_Tensor::Clear();
  clear_has_input();
}
inline const ::Layer::layer_Tensor& layer::input() const {
  return input_ != NULL ? *input_ : *default_instance_->input_;
}
inline ::Layer::layer_Tensor* layer::mutable_input() {
  set_has_input();
  if (input_ == NULL) input_ = new ::Layer::layer_Tensor;
  return input_;
}
inline ::Layer::layer_Tensor* layer::release_input() {
  clear_has_input();
  ::Layer::layer_Tensor* temp = input_;
  input_ = NULL;
  return temp;
}
inline void layer::set_allocated_input(::Layer::layer_Tensor* input) {
  delete input_;
  input_ = input;
  if (input) {
    set_has_input();
  } else {
    clear_has_input();
  }
}

// required .Layer.layer.Tensor output = 3;
inline bool layer::has_output() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void layer::set_has_output() {
  _has_bits_[0] |= 0x00000004u;
}
inline void layer::clear_has_output() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void layer::clear_output() {
  if (output_ != NULL) output_->::Layer::layer_Tensor::Clear();
  clear_has_output();
}
inline const ::Layer::layer_Tensor& layer::output() const {
  return output_ != NULL ? *output_ : *default_instance_->output_;
}
inline ::Layer::layer_Tensor* layer::mutable_output() {
  set_has_output();
  if (output_ == NULL) output_ = new ::Layer::layer_Tensor;
  return output_;
}
inline ::Layer::layer_Tensor* layer::release_output() {
  clear_has_output();
  ::Layer::layer_Tensor* temp = output_;
  output_ = NULL;
  return temp;
}
inline void layer::set_allocated_output(::Layer::layer_Tensor* output) {
  delete output_;
  output_ = output;
  if (output) {
    set_has_output();
  } else {
    clear_has_output();
  }
}

// optional .Layer.layer.Tensor grad_backprop = 4;
inline bool layer::has_grad_backprop() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void layer::set_has_grad_backprop() {
  _has_bits_[0] |= 0x00000008u;
}
inline void layer::clear_has_grad_backprop() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void layer::clear_grad_backprop() {
  if (grad_backprop_ != NULL) grad_backprop_->::Layer::layer_Tensor::Clear();
  clear_has_grad_backprop();
}
inline const ::Layer::layer_Tensor& layer::grad_backprop() const {
  return grad_backprop_ != NULL ? *grad_backprop_ : *default_instance_->grad_backprop_;
}
inline ::Layer::layer_Tensor* layer::mutable_grad_backprop() {
  set_has_grad_backprop();
  if (grad_backprop_ == NULL) grad_backprop_ = new ::Layer::layer_Tensor;
  return grad_backprop_;
}
inline ::Layer::layer_Tensor* layer::release_grad_backprop() {
  clear_has_grad_backprop();
  ::Layer::layer_Tensor* temp = grad_backprop_;
  grad_backprop_ = NULL;
  return temp;
}
inline void layer::set_allocated_grad_backprop(::Layer::layer_Tensor* grad_backprop) {
  delete grad_backprop_;
  grad_backprop_ = grad_backprop;
  if (grad_backprop) {
    set_has_grad_backprop();
  } else {
    clear_has_grad_backprop();
  }
}

// optional .Layer.layer.Kernel kernel = 5;
inline bool layer::has_kernel() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void layer::set_has_kernel() {
  _has_bits_[0] |= 0x00000010u;
}
inline void layer::clear_has_kernel() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void layer::clear_kernel() {
  if (kernel_ != NULL) kernel_->::Layer::layer_Kernel::Clear();
  clear_has_kernel();
}
inline const ::Layer::layer_Kernel& layer::kernel() const {
  return kernel_ != NULL ? *kernel_ : *default_instance_->kernel_;
}
inline ::Layer::layer_Kernel* layer::mutable_kernel() {
  set_has_kernel();
  if (kernel_ == NULL) kernel_ = new ::Layer::layer_Kernel;
  return kernel_;
}
inline ::Layer::layer_Kernel* layer::release_kernel() {
  clear_has_kernel();
  ::Layer::layer_Kernel* temp = kernel_;
  kernel_ = NULL;
  return temp;
}
inline void layer::set_allocated_kernel(::Layer::layer_Kernel* kernel) {
  delete kernel_;
  kernel_ = kernel;
  if (kernel) {
    set_has_kernel();
  } else {
    clear_has_kernel();
  }
}

// optional .Layer.layer.Tensor grad_filter = 6;
inline bool layer::has_grad_filter() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void layer::set_has_grad_filter() {
  _has_bits_[0] |= 0x00000020u;
}
inline void layer::clear_has_grad_filter() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void layer::clear_grad_filter() {
  if (grad_filter_ != NULL) grad_filter_->::Layer::layer_Tensor::Clear();
  clear_has_grad_filter();
}
inline const ::Layer::layer_Tensor& layer::grad_filter() const {
  return grad_filter_ != NULL ? *grad_filter_ : *default_instance_->grad_filter_;
}
inline ::Layer::layer_Tensor* layer::mutable_grad_filter() {
  set_has_grad_filter();
  if (grad_filter_ == NULL) grad_filter_ = new ::Layer::layer_Tensor;
  return grad_filter_;
}
inline ::Layer::layer_Tensor* layer::release_grad_filter() {
  clear_has_grad_filter();
  ::Layer::layer_Tensor* temp = grad_filter_;
  grad_filter_ = NULL;
  return temp;
}
inline void layer::set_allocated_grad_filter(::Layer::layer_Tensor* grad_filter) {
  delete grad_filter_;
  grad_filter_ = grad_filter;
  if (grad_filter) {
    set_has_grad_filter();
  } else {
    clear_has_grad_filter();
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace Layer

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_Layer_2eproto__INCLUDED
